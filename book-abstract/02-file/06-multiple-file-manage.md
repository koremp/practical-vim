# 6장 여러 파일 관리하기

Vim에서 여러 파일을 동시에 작업하는 것도 가능하다.

편집 세션에서 연 파일은 모두 버퍼 목록에서 확인할 수 있다.

Vim은 버퍼 목록을 보조하기 위해서 인자 목록도 제공한다.

* `:args` 명령으로 버퍼 목록에 있는 파일을 묶어 그룹으로 만들기
* `:argdo` 명령으로 그룹으로 만든 파일 목록을 살펴보는 방법과 각각 파일에서 Ex 명령을 실행

## Tip.37 버퍼 목록으로 열린 파일 추적하기

Vim은 여러 파일을 관리할 수 있도록 버퍼 목록을 제공한다.

### 파일과 버퍼의 차이점 이해하기

다른 문서 편집기처럼 Vim에서도 파일을 읽고, 편집하고, 변경 사항을 저장할 수 있다.
실제로는 파일을 편집하는 것이 아니다.

사실은 메모리 공간에 파일을 복사해서 편집을 하는 것이다. 이 메모리에 존재하는 파일의 사본을 Vim에서 사용하는 용어로 버퍼(buffer)라고 한다.

파일은 디스크에 보관하고 버퍼는 메모리에 보관한다. Vim에서 파일을 열면 파일과 동일한 내용을 버퍼에 불러온다.
처음에는 버퍼와 파일의 내용이 일치하지만 버퍼의 내용을 수정하는 순간부터는 내용이 달라진다.
만약 버퍼에서 변경한 사항을 유지하고 싶다면 버퍼의 내용을 다시 파일로 저장하면 된다.

Vim 명령은 대부분 버퍼에서 동작하지만 `:write`, `:update`, `:saveas` 명령처럼 파일을 조작하는 명령도 있다.

### 버퍼 목록 만나기

Vim에서는 동시에 버퍼를 여러 개 사용할 수 있다.

```sh
$ cd code/files
$ vim *.txt
```

`*.txt` 와일드 카드는 현재 디렉토리에 있던 파일 `a.txt`와 `b.txt`에 해당된다.

열려 있는 버퍼를 모두 확인하려면 다음 명령을 사용한다

`:ls`

`:ls` 명령으로 현재 메모리에 존재하는 모든 버퍼 목록을 확인할 수 있다. (`:h ls` 참고)

목록에서 다음 버퍼를 현재 창으로 불러오고 싶다면 `:bnext` 명령을 사용한다.

```vim
:bnext
:ls
```

버퍼 목록에서 `%` 기호는 현재 창에서 볼 수 있는 버퍼를 표시한다.
`#` 기호는 현재 활성된 버퍼와 교대한 버퍼를 나타낸다
`<C-^>` 단축키를 이용하면 현재 버퍼와 이전 버퍼를 빠르게 전환할 수 있다.

### 버퍼 목록 사용하기

Vim에서는 버퍼 목록을 이동하기 위한 네 가지 명령을 제공하고 있다.

`:bprev`, `:bnext`로 전후 이동, `:bfirst`, `:blast` 명령으로 목록의 처음과 끝으로 이동할 수 있다.

`unimpaired.vim` 플러그인에서 매핑을 사용하고 있다.

Vim에서는 이미 비슷한 기능을 하는 명령에 접두어로 `[`와 `]`를 사용하고 있다. (`:h [` 참고)

`:ls`로 목록을 출력해보면 각 버퍼 항목이 숫자로 시작하는 것을 확인할 수 있다.
이 숫자는 버퍼를 생성하면서 자동으로 배정되는 버퍼 번호이다.
이 숫자를 사용해서 `:buffer {버퍼번호}` 명령을 사용하면 그 숫자에 해당하는 버퍼로 바로 이동한다. (`:h :b` 참고)
`:buffer {버퍼명}`을 사용하면 더 직관적으로 사용할 수 있다.
`{버퍼명}`은 파일 경로를 기준으로 각각의 버퍼를 구분할 수 있는 명칭을 사용해야 한다.
입력한 버퍼명이 둘 이상인 경우에는 탭 완성을 사용해서 하나를 선택할 수 있다.

`:bufdo`를 사용하면 `:ls` 버퍼 목록에 있는 모든 버퍼를 대상으로 Ex 명령을 구동할 수 있다. (`:h :bufdo` 참고)
실제로는 `:argdo` 명령을 더 자주 사용하게 된다.

### 버퍼 제거하기

Vim에서는 파일을 새로 열 때마다 버퍼를 생성한다.
버퍼를 제거하고 싶다면 `:bdelete` 명령을 사용한다

사용 예시

* `:bdelete N1 N2 N3`
* `:N,M bdelete`
  * 5번 버퍼부터 10번 버퍼까지 연속된 버퍼를 제거하려면
  * `:5,10bd`

버퍼를 제거해도 버퍼와 연관된 실제 파일에는 영향을 미치지 않는다.
이 명령은 단순히 메모리 내 사본을 제거하는 기능을 한다.

버퍼 번호는 Vim이 자동으로 배정한다.

버퍼 목록을 관리하는 Vim의 내장 기능은 유연성이 부족한 편이다.
이 버퍼 목록을 다시 조정하는 기능이 없다.
대신 작업 환경을 창이나 탭, 인자 목록으로 나눠서 관리할 수 있다.

## Tip.38 인자 목록으로 버퍼 묶음 관리하기

인자 목록은 일련의 파일을 쉽게 이동하고 관리하기 위해 그룹으로 묶는 기능을 제공한다.
`:argdo` 명령을 사용하면 인자 목록에 있는 각각의 파일 항목에서 Ex 명령을 실행할 수 있다.

```sh
$ cvd code/files/letters
$ vim *.txt
:args
```

인자 목록은 Vim을 실행할 때, 인자로 사용한 파일 목록을 확인할 수 있는  기능이다.
출력된 인자 목록에서 볼 수 있는 [] 문자는 인자 목록에서 현재 어느 파일이 열려 있는지 표시한다.

`:ls`명령의 결과와 인자 목록을 비교해보면 입력한 그대로의 모습을 출력한 것이나 마찬가지라는 사실을 알 수 있다.
`:args`의 목록은 Vim을 실행할 당시의 인자를 항상 반영하는 것은 아니다.
기능의 명칭을 그대로 받아들이지 말자.
`:compiler`와 `:make`는 컴파일 언어만을 위한 것이 아니다.

### 인자 목록 출력하기

`:args` Ex 명령을 인자 없이 실행하면 인자 목록에 있는 내용을 출력할 것이다.
인자 목록을 갱신할 수 있다. (`:h :args_f` 참고)

`:args {인자목록}`

`{인자목록}`은 파일명이나 와일드카드, 셸 명령의 출력을 포함할 수 있다.

```sh
$ cd code/files/mvc
$ vim
```

### 이름으로 파일 지정하기

인자 목록에 파일명을 입력하는 가장 간단한 방법은 다음처럼 하나씩 직접 입력하는 방식이다.

```vim
-> :args index.html app.js
-> :args
```

버퍼에서 활용하고 싶은 파일이 몇 개 되지 않는다면 이 방법을 사용해도 된다.
이 방법은 순서를 마음대로 정할 수 있다는 장점이 있다.
직접 입력하는 과정이 수고스럽다는 단점이 있다.

### 글롭(Glob)으로 파일 지정하기

플레이스홀더(placeholder)는 파일이나 디렉터리명을 전부 입력하지 않고도 인자 목록에 파일을 입력할 수 있다.
와일드카드를 플레이스홀더로 사용해서 여러 파일을 동시에 불러올 수 있다.
`*` 기호는 파일명에 문자가 없거나 하나 이상 존재하는 경우를 의미하며, 정해진 딜렉터리 영역 내에서만 동작한다. (`:h wildcard` 참고)

`**` 와일드카드도 팡리명에 문자가 없거나 하나 이상 존재하는 경우를 뜻한다.
특정 디렉터리 안에 존재하는 부 디렉터리까지 모두 재귀적으로 검색해서 파일을 찾는다. (`:h starstar-wildcard` 참고)

요청한 경로와 일치하는 파일 목록을 불러오기 위해 와일드카드 조합해서 파일명 또는 디렉터리명의 형태를 기준으로 모든 파일을 불러올 수 있다.
요청한 경로와 일치하는 파일 목록을 불러오기 위해 와일드카드 조합을 사용할 수 있는데, 이 방법을 글롭(glob)이라고 한다.

글롭
* `:args *.*`: index.html, app.js
* `:args **/*.js`: app.js, lib/framework.js, app/controllers/Mailer.js, ... etc
* `:args **/*.*`: app.js, index.js, lib/theme.css, etc

`{인자목록}`에는 하나 이상의 파일명을 사용할 수 있기 때문에, 여러 개의 글롭을 동시에 요청할 수 있다.

`:args **/*.js **/*.css`

### 역따옴표 확장으로 파일 지정하기

`files/.chapters`

문서로 작성한 파일 목록을 인자 목록으로 불러오기 위해서는 다음의 명령을 사용할 수 있다.

```vim
:args `cat .chapters`
```

Vim은 역따옴표 내에 있는 문자들을 셸 명령으로 처리하고 그 결과를 `:args` 명령의 인자로 사용한다.

위에서 사용한 명령은 셸의 `cat` 명령과 조합해서 `.chapters` 파일의 내용을 인자 목록으로 반환한다. 여기서는 `.chapters` 파일의 내용을 가져오기 위해서 `cat` 명령을 사용했지만 셸에서 구동할 수 있는 명령은 어떤것이든 인자 목록 명령과ㅏ 함께 사용할 수 있다.

이 기능은 모든 시스템에서 동작하지는 않는다. (`:h backtick-expansion` 참고)

### 인자 목록 사용하기

인자 목록은 버퍼 목록보다 간단하다.

파일을 필요에 따라 마음대로 묶어서 관리할 수도 있다.

`:args {인자목록}` 명령을 이용하면 인자 목록을 비우고 다시 입력할 수 있다.
`:next`와 `:prev` 명령을 이용해서 인자 목록에 있는 다음 또는 이전 파일을 버퍼로 불러내는 것도 가능하다.
`:argdo`로 인자 목록의 각각 버퍼에 동일한 명령을 실행할 수 있다

버퍼 목록은 언제나 난장판이 된다.
인자 목록을 활용하면 마치 분리된 작업 공간처럼 각 환경을 단정하게 유지할 수 있다.
필요에 따라 작업 공간을 확장하는 것도 가능하다.

## Tip.39 숨김 파일 관리하기

버퍼를 수정하였지만 실수로 저장하지 않고 종료하는 일을 방지하기 위해서 Vim에서는 수정한 버퍼가 특별하게 다뤄진다.

```sh
$ cd code/files
$ ls
$ vim *.txt
```

`a.txt`에 `Go`를 입력해서 버퍼 마지막에 빈 행을 추가한다.

버퍼목록을 확인하면 `a.txt`에 `+`를 확인할 수 있다. 이 기호는 `a.txt` 버퍼에 변경한 내용이 있다는 의미로 표시된 것이다. 변경한 내용을 저장하면 버퍼 내용을 파일에 작성하게 되고, `+` 기호는 버퍼 목록에서 없어진다.

버퍼를 저장하지 않고 다음 버퍼로 이동해보자

`:bnext`

현재 버퍼에 저장하지 않은 변경이 있다고 오류 메시지가 출력된다. 느낌표 기호를 붙여 다시 명령을 실행한다.

```
:bnext!
:ls
```

`:bnext` 명령에 느낌표 기호를 붙여서 현재 버퍼를 저장하지 않고도 강제로 전환할 수 있다.
`b.txt` 앞의 `a` 문자는 현재 버퍼에 활성화된 파일이라는 것을 표시하는 문자이다.
`a.txt` 앞의 `h` 문자는 숨김 상태로 전환된 버퍼를 뜻한다.

### 종료할 때 숨김 버퍼 처리하기

Vim에서 버퍼를 숨긴 다음에는 마치 평소와 같이 동작할 것이다.

저장하지 않은 버퍼가 있는 상태로 Vim을 닫으려고 한다면 다음처럼 오류가 출력된다

`:quit`

Vim은 수정하고 뒤로 숨겼던 첫 번째 버퍼를 어떻게 처리할지 결정할 수 있도록 현재 창에 불러온다.
변경한 내용을 그대로 유지하려면 `:write` 명령을 사용해 버퍼를 저장할 수 있다.

변경을 취소하고 싶다면 `:edit!` 명령을 입력한다.
이 명령을 사용하면 디스크에 저장되어 있는 파일 내용을 다시 불러와서 현재 버퍼를 덮어씌우고 변경 사항을 모두 되돌린다.

버퍼와 파일 내용이 일치하면 `:quit` 명령을 다시 사용할 수 있다.

`:quit` 명령을 입력했을 때 수정하고 숨겨둔 버퍼가 더 존재한다면, Vim은 앞에서 했던 동작을 다시 반복해서 저장하지 않은 다음 버퍼를 불러온다.
`:write`를 이용해 변경한 내용을 저장하여 유지하거나 `:edit!` 명령을 이용해 변경 사항을 취소한다.
이 과정은 수정하고 숨겨둔 버퍼 수만큼 반복된다.
수정하고 `:q` 명령으로 Vim을 종료할 수 있다.

저장하지 않은 변경 사항을 다시 확인하지 않고 Vim을 종료하려면 `:qall!` 명령을 상요한다.
변경한 모든 버퍼를 하나씩 확인하지 않고 일괄로 저장하는 명령으로 `:wall`을 사용할 수 있다.

숨김 버퍼를 종료하는 방법

- `:w[rite]`: 버퍼의 내용을 디스크에 작성
- `:e[dit]!`: 디스크에서 파일을 다시 읽어 버퍼에 반영 (즉, 변경을 취소)
- `:qa[ll]!`: 모든 창을 닫음, 경고 없이 변경을 모두 취소함
- `:wa[ll]!`: 변경한 모든 버퍼를 디스크에 저장

### :*do 명령을 사용하기 전에 'hidden' 설정 활성화하기

Vim에서는 기본적으로 수정한 버퍼를 그냥 닫을 수 없도록 설정되어 있다.

`:next!`, `:bnext!`, `:cnext!`, 혹은 비슷한 다른 명령을 사용하든 간에 명령 뒤에 느낌표를 붙이지 않으면 '마지막 변경 후에 저장하지 않았습니다'라는 오류 메시지를 만나게 된다. 변경 사항을 상기해주는 게 대부분의 경우에는 유용하지만 다음과 같은 상황에서는 상당히 불편하다.

`:argdo`, `:bufdo`, `:cfdo` 명령을 사용한다고 생각해보자. `:argdo {명령}`은 실제로 다음처럼 동작한다.

```
# vim command
-> :first
-> :{명령}
-> :next
-> :{명령}
< 목록 마지막까지 반복
```

여기서 사용하는 `{명령}`이 버퍼를 수정한다면 `:next` 명령은 오류를 반환할 것이다.

`'hidden'` 설정을 활성화하면 `:next`, `:bnext`, `:cnext` 뿐 아니라 비슷한 명령 모두 느낌표를 뒤에 붙이지 않고 사용할 수 있다. (`:h 'hidden'` 참고)

활성화된 버퍼의 본문을 수정한 다음에 이동 명령을 사용하면 오류 없이 이동할 수 있다. 버퍼는 저장하지 않은 상태 그대로 숨겨진다.

`'hidden'` 설정을 활성화하면 `:argdo`, `:bufdo`, `:cfdo`를 사용해도 오류로 중단되는 일은 없다. 그 덕분에 버퍼 목록의 각 항목을 명령 하나로 일괄 처리할 수 있다.

`:argdo {명령}`을 사용해서 인자 목록의 모든 파일을 일괄로 변경했다면 변경한 내용을 모두 저장해보자.

1. `:first` 명령으로 인자 목록 중 가장 첫 번째 항목으로 이동한다.
2. `:wn` 명령을 사용한다.
   * 이 명령은 현재 버퍼를 저장하고, 바로 다음 버퍼로 이동하는 기능을 제공한다.
3. 인자 목록의 모든 파일을 제대로 변경했고 일괄적으로 저장하고 싶다면 `:argdo write`(또는 `:wall`) 명령을 이용해 한번에 저장할 수 있다.

## Tip.40 작업 환경 창 분리하기

Vim에서는 하나의 작업 공간을 창으로 분리해 여러 버퍼를 동시에 볼 수 있다.
Vim 용어로 창(Window)는 버퍼를 보는 화면을 의미한다.(`:h window` 참고`)
창을 다중으로 열 수도 있고 각각 창에 동일한 버퍼를 띄우거나 다른 버퍼를 띄울 수도 있다.

### 분할 창 생성하기

Vim을 처음 실행되면 단일 창으로 열린다.

* `<C-w>s` 명령으로 이 화면을 상하로 나눌 수 있다.
* `<C-w>v` 명령으로 좌우로 나눌 수 있다.

`<C-w>s`와 `<C-w>v` 명령을 사용할 때마다 창이 분할되는데, 분할 명령을 사용하기 전에 활성화되어 있던 창의 버퍼를 그대로 사용한다. 즉 분할된 창은 동일한 버퍼 화면을 보여주는데, 동일한 버퍼를 다른 창에서 접근할 수 있는 기능은 대형 파일을 편집할 때, 파일 내에 있는 다른 부분을 참조하며 수정하는 상황에서 특히 유용하다.

`:edit` 명령을 사용하면 활성화된 창에 다른 버퍼를 불러올 수 있다.
`:edit {파일명}`을 입력하면 해당 파일을 불러오게 된다.
창을 분리하고 파일을 불러온 두 단계 작업은 `:split {파일명}` 명령을 사용해서 한번에 해결할 수 있다.

* `<C-w>s`: 현재 창을 수평으로 분리, 현재 버퍼를 분리한 창에서 사용함
* `<C-w>v`: 현재 창을 수직으로 분리, 현재 버퍼를 분리한 창에서 사용
* `:sp[lit] {파일명}`: 현재 창을 수평으로 분리, [파일]을 새 창에 불러옴
* `:vssp[lit] {파일명}`: 현재 창을 수직으로 분리, [파일]을 새 창에 불러옴

### 활성화 창 변경하기

Vim에서는 각각 분할된 창에서 활성화된 창을 이동하는 명령을 사용할 수 있다. `:h window-move-cursor`

* `<C-w>w`: 열린 창을 순회하며 이동
* `<C-w>h`: 좌측 창으로 이동
* `<C-w>l`: 우측 창으로 이동
* `<C-w>k`: 상단 창으로 이동
* `<C-w>j`: 하단 창으로 이동

`<Ctrl>`을 누른 상태에서 `ww`를 입력해도 다른 창으로 이동한다.
위 표의 모든 명려은 이 `ww`, `wh` 등의 방식으로 입력이 가능하다.

`'mouse'` 설정이 정상적으로 활성화되었다면 마우스 클릭으로도 활성 창을 변경할 수 있다. (`:h mouse` 참고)

### 창 닫기

1. `:clo[se]` 명령: 현재 활성화된 창을 닫는다.
   * `<C-w>c`
2. `:on[ly]` 명령: 현재 활성화된 창을 제외한 모든 창을 닫는다.
   * `<C-w>o`

### 창 크기 조절 및 재 정렬

`:h window-resize` 참고

* `<C-w>=`: 모든 창의 폭과 높이를 동일하게 조정
* `<C-w>_`: 활성 창 높이 최대화
* `<C-w>|`: 활성 창 폭 최대화
* `[숫자]<C-w>_`: 활성 창 높이를 `[숫자]` 행으로 조정
* `[숫자]<C-w>|`: 활성 창 폭을 `[숫자]` 열로 조정

창 크기 조절 작업은 마우스를 사용하는게 더 편하다.

현재 열려있는 창을 다시 정렬하는 명령도 제공한다. (`:h window-moving` 참고)

## Tip.41 탭으로 창 레이아웃 관리하기

탭 페이지(tab page)는 창 묶음을 보관할 수 있는 공간을 의미한다. (`:h tabpage` 참고)

전형적인 GUI 문서 편집기에서는 파일을 편집하기 위한 주 작업공간(main workspace)과 현재 프로젝트의 디렉터리 구조를 표시하는 측면 영역(side bar)으로 구성된다. 새로운 탭은 각각 파일을 열었을 때 생성된다.

Vim에서는 `:edit` 명령으로 파일을 열었을 때 새로운 탭을 열지 않는다.
새로운 탭을 생성하지 않는 대신에 새로운 버퍼를 생성해서 현재 창에 불러온다.
열린 파일은 버퍼 목록을 사용해서 관리한다.
창은 버퍼와 일대일 관계에 해당하고, 탭은 여러 창을 보관하는 상자에 가깝다.

### 탭을 사용하는 방법

Vim의 탭 페이지는 각각의 작업 공간을 분리하기 위해 사용할 수 있다.
이 기능은 운영체제에서 제공하는 가상 데스크탑 환경에 더 가깝다.

`:lcd {경로}` 명령을 사용하면 현재 창에서 사용하는 작업 경로를 지정할 수 있다.
새로운 탭을 연 다음에 `:lcd` 명령을 사용하면 작업 경로를 다른 디렉터리로 변경할 수 있다.
이 명령으로 각각의 탭 페이지는 해당 탭에서 작업하는 프로젝트 범위(scope) 내에서 작업할 수 있다.
`:lcd` 명령은 경로를 현재 창만 대상으로 하기 때문에 탭 페이지 내에 있는 다른 창의 경로는 작업 경로가 변경되지 않는다.
탭 페이지가 두 개 이상의 창으로 분리되어 있는 경우라면 각각의 창에서 이 명령을 실행해야 하는데 작업 경로를 일괄적으로 설정하고 싶다면 `:window lcd {경로}` 명령을 사용할 수 있다.

### 탭 열고 닫기

새로운 탭을 열기 위해서는 `:tabedit {파일명}` 명령을 사용한다.
`{파일명}`을 입력하지 않고 명령을 사용하면 새로운 탭 페이지가 열리며 그 탭 페이지에는 빈 버퍼가 포함된다.

현재 탭 페이지에 여러 창이 있을 때, `<C-w>T` 명령을 사용해서 현재 창을 새로운 탭 페이지로 이동할 수 있다. (`:h CTRL-W_T` 참고`)

활성 탭 페이지에 창이 하나만 있을 경우에 `:close` 명령을 입력하면 창과 탭 페이지를 한번에 닫는다.
`:tabclose` 명령을 사용하면 현재 탭에 열려 있는 창의 숫자와 상관없이 탭을 닫을 수 있다.
현재 탭을 제외하고 다른 탭을 모두 닫고싶다면 `:tabonly` 명령을 사용할 수 있다.

* `:tabe[dit] {filename}`: {파일명}을 새 탭에서 열기
* `<C-w>T`: 현재 탭에서 활성화 창을 새 탭으로 열기
* `:tabc[lose]`: 현재 탭과 탭에 열린 모든 창 닫기
* `:tabo[nly]`: 현재 활성화된 탭 페이지를 제외한 모든 탭 닫기

### 탭 이동하기

탭은 1부터 차례로 숫자가 매겨진다.
`{숫자}gt` 명령을 사용하면 `{숫자}`번째 탭으로 이동할 수 있따.
특정 탭으로 이동하고 싶다면 명령 앞에 숫자를 사용한다.
숫자를 입력하지 않으면 다음 탭으로 이동한다.
`gT`는 동일한 기능을 하지만 반대 방향으로 동작한다.

* `tabn[ext] {숫자}` - `{숫자}gt`: `{숫자}`번째 탭 페이지로 이동
* `tabn[ext]` - `gt`: 다음 탭 페이지로 이동
* `tabp[revious]` - `gT`: 이전 탭 페이지로 이동

### 탭 다시 정렬하기

탭 페이지의 순서를 정렬하고 싶다면 `:tabmove [숫자]` Ex 명령을 사용할 수 있다.
`[숫자]`는 이동하고 싶은 위치를 입력하는데 `0`을 입력하면 현재 탭을 탭 페이지 순서에서 가장 앞으로 옮긴다.
`[숫자]`를 입력하지 않으면 현재 탭을 가장 끝으로 옮긴다.